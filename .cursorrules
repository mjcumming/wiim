# WiiM Home Assistant Integration - Cursor Rules

## Project Identity

**This is a SIMPLE WRAPPER around the `pywiim` library.**

- We sit between Home Assistant and the `pywiim` library
- We do NOT implement device communication logic - `pywiim` does that
- We do NOT write code beyond integrating `pywiim` with Home Assistant
- We follow Home Assistant best design principles for integrations
- We write tests for all integration code

## Core Principles

### 1. Simple Wrapper Pattern

**DO:**

- Use `pywiim` classes directly (`WiiMClient`, `Player`, `UpnpClient`, etc.)
- Pass data from `pywiim` to Home Assistant entities
- Handle HA-specific concerns (config entries, coordinators, entities)
- Use `pywiim` helpers (`PollingStrategy`, `TrackChangeDetector`, `fetch_parallel`)

**DO NOT:**

- Implement HTTP API calls - use `WiiMClient` methods
- Implement UPnP client logic - use `UpnpClient` from `pywiim`
- Implement polling logic - use `PollingStrategy` from `pywiim`
- Write device communication code - `pywiim` handles all device interaction
- Duplicate functionality that exists in `pywiim`

### 2. Home Assistant Best Practices

**Follow HA Integration Patterns:**

- **Coordinator**: Use `DataUpdateCoordinator` for polling (see `development/HA Integraion.md`)
- **Config Flow**: Standard HA config flow with discovery support
- **Entities**: Inherit from `CoordinatorEntity` when possible
- **Platforms**: Use standard HA platforms (media_player, sensor, switch, etc.)
- **Error Handling**: Use HA exceptions (`ConfigEntryNotReady`, `UpdateFailed`)
- **Session Management**: Use `async_get_clientsession(hass)` for HTTP client
- **Type Hints**: Use proper typing with `ConfigEntry` generics
- **Logging**: Use module-level logger, not print statements

**File Structure:**

```
custom_components/wiim/
├── __init__.py          # Entry point, setup/unload
├── config_flow.py       # Configuration flow
├── coordinator.py       # DataUpdateCoordinator wrapper
├── const.py             # Constants
├── models.py            # Pydantic models (if needed)
├── entity.py            # Base entity classes
├── data.py              # Runtime data structures
├── media_player.py      # Media player platform
├── sensor.py            # Sensor platform
├── switch.py            # Switch platform
├── ...                  # Other platforms
└── manifest.json        # Integration manifest
```

### 3. Integration Architecture

**Follow the pattern in `development/HA Integraion.md`:**

1. **Use `WiiMClient` directly** (not `Player` for basic operations)

   - HA's `DataUpdateCoordinator` manages state caching
   - Direct access to all endpoints (`get_multiroom_status()`, `get_audio_output_status()`, etc.)

2. **Use `PollingStrategy`** for adaptive polling intervals

   - Let `pywiim` recommend intervals based on device state
   - Update `coordinator.update_interval` dynamically

3. **Use conditional fetching helpers** from `PollingStrategy`

   - `should_fetch_device_info()`, `should_fetch_multiroom()`, etc.
   - Avoid unnecessary API calls

4. **Use `TrackChangeDetector`** for metadata fetching

   - Only fetch metadata when track changes

5. **Optional: UPnP for events and queue**
   - Use `UpnpClient` and `UpnpEventer` from `pywiim` if needed
   - Integration creates UPnP client (not HA core, not pywiim)

### 4. Testing Requirements

**All code must have tests:**

- **Unit tests**: Test coordinator logic, entity logic, data transformations
- **Integration tests**: Test full setup/teardown, config flow, entity creation
- **Mock `pywiim`**: Use mocks/fixtures for `WiiMClient` and other `pywiim` classes
- **Test coverage**: Aim for >80% coverage on integration code

**Test Structure:**

```
tests/
├── conftest.py          # Shared fixtures
├── unit/                # Unit tests
│   ├── test_coordinator.py
│   ├── test_entities.py
│   └── ...
└── integration/         # Integration tests
    ├── test_config_flow.py
    ├── test_setup.py
    └── ...
```

### 5. Code Boundaries

**What This Integration Does:**

- ✅ Wraps `pywiim` classes for HA consumption
- ✅ Implements HA platforms (media_player, sensor, etc.)
- ✅ Handles HA config flow and discovery
- ✅ Manages coordinator lifecycle
- ✅ Transforms `pywiim` data models to HA entity states
- ✅ Implements HA services and entity methods

**What This Integration Does NOT Do:**

- ❌ Implement device API communication
- ❌ Implement UPnP protocol handling
- ❌ Implement polling strategies (use `PollingStrategy` from `pywiim`)
- ❌ Implement device capability detection (use `pywiim` methods)
- ❌ Write HTTP client code (use `WiiMClient` from `pywiim`)
- ❌ Write UPnP client code (use `UpnpClient` from `pywiim`)

### 6. Import Guidelines

**Always import from `pywiim`:**

```python
from pywiim import WiiMClient, PollingStrategy, TrackChangeDetector
from pywiim.exceptions import WiiMError, WiiMConnectionError, WiiMTimeoutError
```

**Use optional imports for optional features:**

```python
try:
    from pywiim import Player, UpnpClient
    UPNP_AVAILABLE = True
except ImportError:
    UPNP_AVAILABLE = False
    Player = None
    UpnpClient = None
```

### 7. Error Handling

**Use HA exceptions:**

- `ConfigEntryNotReady` - Device not available during setup
- `UpdateFailed` - Coordinator update failed
- `HomeAssistantError` - General HA errors

**Catch `pywiim` exceptions:**

- `WiiMError` - General device error
- `WiiMConnectionError` - Connection issues
- `WiiMTimeoutError` - Request timeout

**Pattern:**

```python
try:
    result = await self.client.get_player_status()
except (WiiMConnectionError, WiiMTimeoutError) as err:
    raise ConfigEntryNotReady(f"Device unavailable: {err}") from err
except WiiMError as err:
    raise UpdateFailed(f"Device error: {err}") from err
```

### 8. Documentation

**Reference the integration guide:**

- Always check `development/HA Integraion.md` for patterns
- Follow examples in the guide
- Don't reinvent patterns - use what's documented

### 9. Code Review Checklist

Before writing code, ask:

- [ ] Is this functionality already in `pywiim`? (If yes, use it)
- [ ] Am I implementing device communication? (If yes, STOP - use `pywiim`)
- [ ] Am I following HA best practices? (Check `development/HA Integraion.md`)
- [ ] Do I have tests for this code?
- [ ] Am I using `pywiim` helpers (`PollingStrategy`, `TrackChangeDetector`)?
- [ ] Am I using HA's shared session (`async_get_clientsession`)?

### 10. Common Mistakes to Avoid

**❌ DON'T:**

- Write HTTP client code - use `WiiMClient`
- Implement polling logic - use `PollingStrategy`
- Duplicate `pywiim` functionality
- Skip tests
- Use blocking I/O - everything must be async
- Create custom state management - use HA's coordinator
- Hardcode intervals - use `PollingStrategy` recommendations

**✅ DO:**

- Use `pywiim` classes directly
- Follow HA patterns from `development/HA Integraion.md`
- Write tests for all code
- Use async/await throughout
- Use HA's coordinator for state management
- Use `PollingStrategy` for intervals

## Quick Reference

**Key Files:**

- `development/HA Integraion.md` - Integration guide (READ THIS FIRST)
- `custom_components/wiim/coordinator.py` - Coordinator implementation
- `custom_components/wiim/__init__.py` - Entry point

**Key Classes:**

- `WiiMCoordinator` - Wraps `WiiMClient` with HA coordinator
- `Speaker` - Runtime data structure
- Platform entities - Media player, sensors, switches, etc.

**Key Patterns:**

- Coordinator uses `WiiMClient` directly
- Use `PollingStrategy` for intervals
- Use conditional fetching helpers
- Use `TrackChangeDetector` for metadata
- Optional UPnP for events/queue

## Remember

**This is a wrapper, not a device library.**
**`pywiim` does the device communication.**
**We just integrate it with Home Assistant.**
